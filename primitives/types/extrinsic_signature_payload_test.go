package types

// TODO:
// import (
// 	"encoding/hex"
// 	"testing"

// 	sc "github.com/LimeChain/goscale"
// 	"github.com/stretchr/testify/assert"
// )

// func Test_UsingEncoded_SignedPayload256(t *testing.T) {
// 	blockHash, _ := hex.DecodeString("0x0f6d3477739f8a65886135f58c83ff7c2d4a8300a010dfc8b4c5d65ba37920bb")

// 	signedPayload := SignedPayload{
// 		Call: sc.NewFixedSequence(241, []sc.U8{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}...),
// 		Extra: SignedExtra{
// 			Era:   NewImmortalEra(),
// 			Nonce: 0,
// 			Fee:   0,
// 		},
// 		AdditionalSigned: AdditionalSigned{
// 			SpecVersion:        100,
// 			TransactionVersion: 1,
// 			GenesisHash:        H256{FixedSequence: sc.BytesToFixedSequenceU8(blockHash)},
// 			BlockHash:          H256{FixedSequence: sc.BytesToFixedSequenceU8(blockHash)},
// 		},
// 	}
// 	t.Log(len(signedPayload.Bytes()))

// 	var testExamples = []struct {
// 		label       string
// 		input       SignedPayload
// 		expectation []byte
// 	}{
// 		{
// 			label:       "UsingEncoded SignedPayload()",
// 			input:       signedPayload,
// 			expectation: []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x64, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0},
// 		},
// 	}

// 	for _, testExample := range testExamples {
// 		t.Run(testExample.label, func(t *testing.T) {
// 			enc := sc.SequenceU8ToBytes(testExample.input.UsingEncoded())
// 			assert.Equal(t, testExample.expectation, enc)
// 		})
// 	}
// }

// func Test_UsingEncoded_SignedPayload257(t *testing.T) {
// 	blockHash, _ := hex.DecodeString("0x0f6d3477739f8a65886135f58c83ff7c2d4a8300a010dfc8b4c5d65ba37920bb")

// 	signedPayload := SignedPayload{
// 		Call: sc.NewFixedSequence(246, []sc.U8{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}...),
// 		Extra: SignedExtra{
// 			Era:   NewImmortalEra(),
// 			Nonce: 0,
// 			Fee:   0,
// 		},
// 		AdditionalSigned: AdditionalSigned{
// 			SpecVersion:        100,
// 			TransactionVersion: 1,
// 			GenesisHash:        H256{FixedSequence: sc.BytesToFixedSequenceU8(blockHash)},
// 			BlockHash:          H256{FixedSequence: sc.BytesToFixedSequenceU8(blockHash)},
// 		},
// 	}
// 	t.Log(len(signedPayload.Bytes()))

// 	var testExamples = []struct {
// 		label       string
// 		input       SignedPayload
// 		expectation []byte
// 	}{
// 		{
// 			label:       "UsingEncoded SignedPayload()",
// 			input:       signedPayload,
// 			expectation: []byte{0xa0, 0x85, 0x35, 0xe9, 0x46, 0xe0, 0x95, 0x7c, 0x1a, 0x2d, 0x2c, 0x4c, 0x18, 0x38, 0x67, 0x65, 0xb7, 0x33, 0x2d, 0x5a, 0x5e, 0x88, 0x4d, 0x54, 0xb6, 0x48, 0xd8, 0xa8, 0x1c, 0x2b, 0x9, 0xc0},
// 		},
// 	}

// 	for _, testExample := range testExamples {
// 		t.Run(testExample.label, func(t *testing.T) {
// 			enc := sc.SequenceU8ToBytes(testExample.input.UsingEncoded())
// 			assert.Equal(t, testExample.expectation, enc)
// 		})
// 	}
// }
